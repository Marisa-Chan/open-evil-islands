   * This is an internal documentation currently available only on Russian.
     Something more better will be later.

   * Дизайн подсистемы ввода.
     Низкий уровень.
     На низком уровне доступны лишь несколько примитивных функций.

     Инициализация подсистемы:
     bool input_open(void);

     На каждом игровом цикле необходимо обновлять
     внутренние структуры подсистемы:
     void input_advance(float elapsed);

     bool input_test(input_button button);
     Функция даёт простой ответ, нажата ли такая клавиша.

     int input_mouse_offset_*();
     Эти функции возвращают относительные смещения курсора мыши.

     Высокий уровень.
     На высоком уровне доступны события ввода. Комбинируя события в
     иерархическую структуру, можно задавать условия, по которым будет
     срабатывать событие-корень иерархии. Также можно задавать
     различные сочетания клавиш.

     Первое, что необходимо сделать - это создать поставщика (он же и
     хранитель) событий. Он создан для удобства и предоставления
     унифицированного доступа к хранимым событиям.

     input_event_supply* input_event_supply_open(void);
     Функция создаёт новый экземпляр поставщика.

     С помощью поставщика можно начать создавать события:
     input_event* input_create_*_event(input_event_supply* es, ...);

     void input_event_supply_advance(input_event_supply* es, float elapsed);
     На каждом игровом цикле нужно вызывать функцию обновления поставщика.
     Поставщик сам обновит все хранимые у себя события.

     void input_event_supply_close(input_event_supply* es);
     Уничтожает поставщика и все события, сделанные с помощью него.
     Все указатели на эти события становятся недействительными.

     bool input_event_triggered(input_event* ev);
     Функция проверяет, сработало ли событие.

   * Пример использования.
     Пример будет составлен из тех событий, которые имеются на данный момент.

     На какую-то клавишу мы хотим задать переключение какого-то режима в игре.
     Низкого уровня недостаточно, т.к. функция input_test будет возвращать
     положительный ответ снова и снова, пока нажата клавиша.
     Как результат - многократное переключение режима туда и обратно.
     Причём при отжатии кнопки режим может остаться тем же, каким и был.

     Хотелось бы переключить режим один раз в момент нажатия кнопки.
     Что происходит дальше - сколько времени кнопка нажата, когда отжата -
     нас не интересует. Всё это можно сделать с помощью событий.

     input_open();
     input_event_supply* es = input_event_supply_open();

     input_event* x_key_event = input_create_button_event(es, KB_X);
     input_event* main_event = input_create_single_front_event(es, x_key_event);
     ...
     input_advance(elapsed);
     input_event_supply_advance(es, elapsed);
     ...
     if (input_event_triggered(main_event)) {
         ...
     }

     input_event_supply_close(es);
     input_close();

     В приведённом выше коде создаётся событие нажатия кнопки x,
     которое, в свою очередь, помещается в событие-фильтр single_front_event.
     Это событие сработает только один раз, когда нажата клавиша.
     Естественно, когда клавиша отжата и снова нажата,
     событие сработает вновь один раз. Это то, чего мы и добивались.

   * Что планируется.
     Планируется создание базового набора полезных событий, таких как and, or.
